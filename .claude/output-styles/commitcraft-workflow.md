---
name: CommitCraft Workflow
description: Output formatting and coordination standards for CommitCraft multi-agent commit workflow
---

## CommitCraft Workflow Coordination

### Purpose
CommitCraft is a multi-agent workflow that analyzes repository changes, groups files logically, generates conventional commit messages, validates quality and security, and executes commits. This output style defines coordination patterns and output formats.

---

## Agent Pipeline Architecture

```
commit-analyzer → commit-grouper → commit-message → commit-validator → commit-executor
     ↓                 ↓                 ↓                 ↓                 ↓
  00-*.md          01-*.md           02-*.md           03-*.md           04-*.md
     +                 +                 +                 +                 +
  *.json            *.json            *.json            *.json            *.json
```

### Session Directory Structure

**Location**: `.claude/commitcraft/commitcraft-YYYYMMDD-HHMMSS/`

```
.claude/commitcraft/commitcraft-20250121-143025/
├── 00-repository-analysis.md       # Human-readable analysis report
├── 01-grouping-strategy.md         # Logical grouping documentation
├── 02-commit-messages.md           # Generated commit messages
├── 03-validation-report.md         # Quality & security validation
├── 04-execution-log.md             # Commit execution results
├── 05-session-summary.md           # Consolidated summary (generated by script)
└── data/
    ├── repository-analysis.json    # Source of truth: features, changes, dependencies
    ├── grouping-strategy.json      # Source of truth: logical groups
    ├── commit-messages.json        # Source of truth: messages by group
    ├── validation-report.json      # Source of truth: quality scores, security issues
    └── execution-log.json          # Source of truth: git commit results
```

---

## Coordination Principles

### 1. Context Loading Pattern

**Rule**: Each agent MUST load previous phase outputs from session directory.

**Example** (commit-grouper loading from commit-analyzer):
```javascript
const sessionDir = ".claude/commitcraft/commitcraft-20250121-143025"
const analysis = JSON.parse(Read(`${sessionDir}/data/repository-analysis.json`))

const features = analysis.features_detected  // [{name, type, files, complexity}]
const changes = analysis.changes             // [{file, category, feature, lines_changed}]
const dependencies = analysis.dependencies   // [{file, used_by}]
```

**Context Chain**:
- `commit-analyzer` → Creates session, generates analysis
- `commit-grouper` → Loads `repository-analysis.json`
- `commit-message` → Loads `grouping-strategy.json` + `repository-analysis.json`
- `commit-validator` → Loads `commit-messages.json` + `grouping-strategy.json`
- `commit-executor` → Loads `validation-report.json` + `commit-messages.json`

### 2. Dual Output Format

**Rule**: Every agent MUST generate both JSON (data) and Markdown (documentation).

**Rationale**:
- **JSON** = Source of truth for next agent (machine-readable)
- **Markdown** = Human-readable report for review and audit

**Output Pattern**:
```javascript
// 1. Generate JSON data
const outputData = {
  metadata: { timestamp, session_id, agent: "commit-grouper" },
  // ... agent-specific data
}
Write(`${sessionDir}/data/grouping-strategy.json`, JSON.stringify(outputData, null, 2))

// 2. Generate Markdown report
const markdown = generateMarkdownReport(outputData)
Write(`${sessionDir}/01-grouping-strategy.md`, markdown)
```

### 3. Session Timestamp Format

**Rule**: Use `commitcraft-YYYYMMDD-HHMMSS` format for session IDs.

**Example**:
```bash
sessionId="commitcraft-$(date +%Y%m%d-%H%M%S)"  # commitcraft-20250121-143025
sessionDir=".claude/commitcraft/${sessionId}"
```

**Why**: Sortable, human-readable, unique per execution.

### 4. Error Handling

**Rule**: Agents MUST handle missing dependencies gracefully.

**Pattern**:
```javascript
// Check previous phase output exists
if (!fileExists(`${sessionDir}/data/repository-analysis.json`)) {
  return {
    error: "missing_input",
    message: "repository-analysis.json not found - run commit-analyzer first",
    session: sessionDir
  }
}
```

### 5. Quality Validation Blocking

**Rule**: commit-executor MUST NOT execute commits if validation fails.

**Decision Logic**:
```javascript
const validation = JSON.parse(Read(`${sessionDir}/data/validation-report.json`))

if (validation.overall_status === "blocked") {
  console.log("❌ BLOCKED: Critical security issues detected")
  console.log("Fix issues before committing")
  return { status: "blocked", reason: validation.blocking_issues }
}

if (validation.overall_status === "needs_improvement") {
  console.log("⚠️  WARNING: Quality issues detected")
  console.log("Consider addressing issues before committing")
  // Allow execution with warning
}
```

---

## Stage Gating Rules

### Purpose
Stage gating ensures each phase completes successfully and produces valid outputs before the next phase begins. This prevents cascading failures and maintains data integrity throughout the workflow.

### Gating Mechanism

**Each agent MUST verify entry conditions before execution:**

```javascript
function verifyStageGate(stage, sessionDir) {
  const gates = {
    'commit-analyzer': {
      // No prerequisites - first stage
      required: [],
      verify: () => true
    },

    'commit-grouper': {
      required: ['data/repository-analysis.json', '00-repository-analysis.md'],
      verify: (sessionDir) => {
        const analysis = JSON.parse(Read(`${sessionDir}/data/repository-analysis.json`))
        return analysis.features_detected && analysis.features_detected.length > 0
      }
    },

    'commit-message': {
      required: ['data/grouping-strategy.json', '01-grouping-strategy.md'],
      verify: (sessionDir) => {
        const grouping = JSON.parse(Read(`${sessionDir}/data/grouping-strategy.json`))
        return grouping.groups && grouping.groups.length > 0
      }
    },

    'commit-validator': {
      required: ['data/commit-messages.json', '02-commit-messages.md'],
      verify: (sessionDir) => {
        const messages = JSON.parse(Read(`${sessionDir}/data/commit-messages.json`))
        return messages.groups && messages.groups.every(g => g.commit_message)
      }
    },

    'commit-executor': {
      required: ['data/validation-report.json', '03-validation-report.md'],
      verify: (sessionDir) => {
        const validation = JSON.parse(Read(`${sessionDir}/data/validation-report.json`))
        // CRITICAL: Block execution if not approved
        if (validation.overall_status === 'blocked') {
          throw new Error('❌ GATE BLOCKED: Critical security issues detected')
        }
        return validation.overall_status === 'approved'
      }
    }
  }

  const gate = gates[stage]

  // Check all required files exist
  for (const file of gate.required) {
    if (!fileExists(`${sessionDir}/${file}`)) {
      throw new Error(`❌ GATE FAILED: Missing required file ${file}`)
    }
  }

  // Verify data integrity
  if (!gate.verify(sessionDir)) {
    throw new Error(`❌ GATE FAILED: Data validation failed for ${stage}`)
  }

  console.log(`✅ GATE PASSED: ${stage} can proceed`)
  return true
}
```

### Gate Status Indicators

**Visual Status Markers**:
- ✅ `GATE PASSED` - All prerequisites met, agent can proceed
- ⚠️ `GATE WARNING` - Non-critical issues, agent can proceed with caution
- ❌ `GATE BLOCKED` - Critical failure, agent MUST NOT proceed

### Gate Enforcement Points

**commit-pilot MUST enforce gates at each stage**:

```javascript
// Phase 1: Analysis (no gate)
await Task({ subagent_type: "commit-analyzer", ... })

// Phase 2: Grouping (gate: analysis complete)
verifyStageGate('commit-grouper', sessionDir)
await Task({ subagent_type: "commit-grouper", ... })

// Phase 3: Message Generation (gate: grouping complete)
verifyStageGate('commit-message', sessionDir)
await Task({ subagent_type: "commit-message", ... })

// Phase 4: Validation (gate: messages generated)
verifyStageGate('commit-validator', sessionDir)
await Task({ subagent_type: "commit-validator", ... })

// Phase 5: Execution (gate: validation approved)
verifyStageGate('commit-executor', sessionDir)
await Task({ subagent_type: "commit-executor", ... })
```

### Critical Gate: Validation → Execution

**BLOCKING GATE**: The validator → executor gate is the most critical:

```javascript
const validation = JSON.parse(Read(`${sessionDir}/data/validation-report.json`))

// BLOCKING CONDITIONS (MUST halt workflow):
if (validation.overall_status === 'blocked') {
  console.log('❌ BLOCKED: Security issues detected')
  console.log(validation.blocking_issues.map(i => `  - ${i.message}`).join('\n'))
  throw new Error('Workflow halted: Fix security issues before committing')
}

// WARNING CONDITIONS (allow with confirmation):
if (validation.overall_status === 'needs_improvement') {
  console.log('⚠️ WARNING: Quality score below 90')
  console.log('Consider improving commit messages before proceeding')

  if (!options.skip_validation && !options.quick) {
    // Request user confirmation
    const proceed = askUserConfirmation('Proceed anyway? [y/N]')
    if (!proceed) {
      throw new Error('Workflow cancelled by user')
    }
  }
}

// APPROVED - proceed
console.log('✅ Validation passed - proceeding to execution')
```

### Gate Failure Recovery

**When a gate fails**:

1. **Log the failure** to session directory
   ```javascript
   Write(`${sessionDir}/gate-failure.log`, JSON.stringify({
     stage: stage,
     timestamp: new Date().toISOString(),
     reason: error.message,
     required_files: gate.required,
     recovery_steps: getRecoverySteps(stage)
   }))
   ```

2. **Provide recovery guidance**
   ```javascript
   console.log(`\n❌ Gate failed for ${stage}`)
   console.log(`\nRecovery steps:`)
   console.log(`1. Check ${sessionDir}/ for missing files`)
   console.log(`2. Re-run previous agent: commit-pilot --stage=${previousStage}`)
   console.log(`3. Review ${sessionDir}/gate-failure.log for details`)
   ```

3. **Halt workflow** - Do NOT proceed to next stage

### Stage-Specific Gates

#### Gate 1: analyzer → grouper
**Required**: Valid feature detection
**Verification**: At least 1 feature detected
**Failure**: "No features detected - cannot group files"

#### Gate 2: grouper → message
**Required**: Valid file groups
**Verification**: All groups have files and features assigned
**Failure**: "Invalid grouping - missing file assignments"

#### Gate 3: message → validator
**Required**: Complete commit messages
**Verification**: All groups have non-empty messages
**Failure**: "Missing commit messages for some groups"

#### Gate 4: validator → executor (CRITICAL)
**Required**: Approved validation status
**Verification**: overall_status === 'approved'
**Failure**: "Validation failed - security or quality issues detected"

---

## Output Format Standards

### JSON Schema Patterns

#### repository-analysis.json
```json
{
  "analysis_timestamp": "2025-01-21T14:20:00Z",
  "session_id": "commitcraft-20250121-142000",
  "summary": {
    "total_files": 12,
    "modified": 8,
    "added": 3,
    "deleted": 1,
    "total_lines_added": 450,
    "total_lines_deleted": 180
  },
  "features_detected": [
    {
      "name": "authentication",
      "type": "feature",
      "files": ["src/auth/login.js", "src/auth/auth.service.js"],
      "complexity": "high",
      "total_lines_changed": 350
    }
  ],
  "changes": [
    {
      "file": "src/auth/login.js",
      "status": "added",
      "category": "code",
      "feature": "authentication",
      "lines_added": 120,
      "lines_deleted": 0
    }
  ],
  "dependencies": [
    {
      "file": "src/auth/login.js",
      "used_by": ["src/app.js"],
      "imports": ["./auth.service.js", "jsonwebtoken"]
    }
  ]
}
```

#### grouping-strategy.json
```json
{
  "timestamp": "2025-01-21T14:25:00Z",
  "session_id": "commitcraft-20250121-142000",
  "total_files": 12,
  "groups": [
    {
      "group_id": "group-001",
      "feature": "authentication",
      "type": "feature-implementation",
      "files": ["src/auth/login.js", "src/auth/auth.service.js"],
      "total_lines_changed": 205,
      "commit_order": 1,
      "dependencies": [],
      "rationale": "Core authentication logic - implements JWT-based login"
    }
  ]
}
```

#### commit-messages.json
```json
{
  "timestamp": "2025-01-21T14:30:00Z",
  "session_id": "commitcraft-20250121-142000",
  "language": "en",
  "groups": [
    {
      "group_id": "group-001",
      "feature": "authentication",
      "message": "feat(auth): implement JWT-based user authentication\n\nChanges:\n- Add JWT token generation on login\n- Implement token validation middleware\n- Create refresh token endpoint\n\nImplementation:\n- Using jsonwebtoken library (v9.0.0)\n- Tokens expire after 1 hour\n- Refresh tokens valid for 7 days\n\n🤖 Generated with [Claude Code](https://claude.com/claude-code)\n\nCo-Authored-By: Claude <noreply@anthropic.com>",
      "files": ["src/auth/login.js", "src/auth/auth.service.js"]
    }
  ]
}
```

#### validation-report.json
```json
{
  "timestamp": "2025-01-21T14:35:00Z",
  "session_id": "commitcraft-20250121-142000",
  "overall_status": "approved",
  "overall_score": 92.5,
  "summary": {
    "approved": 4,
    "needs_improvement": 1,
    "blocked": 0
  },
  "validations": [
    {
      "group_id": "group-001",
      "feature": "authentication",
      "status": "approved",
      "quality_score": 95,
      "quality_breakdown": {
        "format": 25,
        "clarity": 24,
        "completeness": 23,
        "convention": 23
      },
      "security_status": "clean",
      "security_checks": [],
      "issues": [],
      "recommendations": ["Consider adding more implementation details"]
    }
  ]
}
```

#### execution-log.json
```json
{
  "timestamp": "2025-01-21T14:40:00Z",
  "session_id": "commitcraft-20250121-142000",
  "total_commits": 4,
  "summary": {
    "successful_commits": 4,
    "failed_commits": 0
  },
  "executions": [
    {
      "group_id": "group-001",
      "feature": "authentication",
      "status": "success",
      "git_commit": {
        "commit_hash": "a1b2c3d4",
        "message": "feat(auth): implement JWT-based user authentication",
        "files": ["src/auth/login.js", "src/auth/auth.service.js"],
        "timestamp": "2025-01-21T14:40:15Z"
      }
    }
  ],
  "errors": []
}
```

### Markdown Report Standards

#### Header Format
All markdown reports MUST start with:
```markdown
# [Report Title]

**Session**: commitcraft-YYYYMMDD-HHMMSS
**Generated**: YYYY-MM-DD HH:MM:SS
**Status**: [✅ Success | ⚠️ Warning | ❌ Blocked]

---
```

#### Section Hierarchy
- `#` - Report title
- `##` - Major sections
- `###` - Subsections (features, groups, commits)
- `####` - Details

#### Status Icons
- ✅ - Success, approved, completed
- ⚠️ - Warning, needs improvement
- ❌ - Blocked, failed, critical issue
- 📊 - Statistics, metrics
- 🔍 - Analysis, details
- 🔒 - Security-related

---

## TodoWrite Coordination

### Rule: TodoWrite BEFORE Execution

**Pattern**:
```javascript
// 1. Create TodoWrite at workflow start
TodoWrite([
  { content: "Analyze repository changes", status: "pending", activeForm: "Analyzing repository changes" },
  { content: "Group files into logical commits", status: "pending", activeForm: "Grouping files" },
  { content: "Generate commit messages", status: "pending", activeForm: "Generating commit messages" },
  { content: "Validate quality and security", status: "pending", activeForm: "Validating commits" },
  { content: "Execute git commits", status: "pending", activeForm: "Executing commits" }
])

// 2. Update status as each agent completes
TodoWrite([
  { content: "Analyze repository changes", status: "completed", activeForm: "Analyzing repository changes" },
  { content: "Group files into logical commits", status: "in_progress", activeForm: "Grouping files" },
  // ...
])
```

### Agent Responsibility
- Each agent updates its own todo status
- Use `in_progress` when starting work
- Use `completed` only when outputs are written
- NEVER mark as `completed` if errors occurred

---

## Workflow Invocation Patterns

### Option 1: Full Workflow (commit-pilot)
```bash
# Execute entire pipeline
/commit-pilot --language=en
```

**Behavior**:
1. Creates session directory
2. Invokes commit-analyzer using Task()
3. Invokes commit-grouper using Task()
4. Invokes commit-message using Task()
5. Invokes commit-validator using Task()
6. Invokes commit-executor using Task()
7. Generates session summary

### Option 2: Phase-by-Phase (batch-commit)
```bash
# Execute multiple features sequentially
/batch-commit --features "auth,api,ui"
```

**Behavior**:
1. Analyzes all changes once
2. For each feature:
   - Group files for feature
   - Generate message
   - Validate
   - Execute commit

### Option 3: Individual Commands
```bash
# Analyze only
/analyze

# Group files
/group

# Generate messages
/commit-message

# Validate
/validate
```

---

## Best Practices

### 1. Always Load Previous Context
```javascript
// ❌ BAD: Assuming data structure
const files = ["src/auth/login.js", "src/auth/auth.service.js"]

// ✅ GOOD: Loading from previous phase
const grouping = JSON.parse(Read(`${sessionDir}/data/grouping-strategy.json`))
const files = grouping.groups[0].files
```

### 2. Validate Input Before Processing
```javascript
// Check required fields exist
if (!analysis.features_detected || !analysis.changes) {
  throw new Error("Invalid repository-analysis.json: missing required fields")
}
```

### 3. Preserve Session Context
```javascript
// Always include session_id in outputs
const output = {
  session_id: sessionId,  // Link to session
  timestamp: new Date().toISOString(),
  // ... rest of data
}
```

### 4. Use HEREDOC for Git Commits
```bash
# ✅ GOOD: Proper multiline handling
git commit -m "$(cat <<'EOF'
feat(auth): implement JWT authentication

Changes:
- Add login endpoint
- Implement token validation

🤖 Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
EOF
)"
```

### 5. Generate Summary Last
```bash
# After all phases complete
~/.claude/scripts/commitcraft-doc-generator.sh "${sessionDir}"
```

---

## Error Recovery

### Handling Missing Input
```javascript
const analysisPath = `${sessionDir}/data/repository-analysis.json`
if (!fileExists(analysisPath)) {
  console.log("❌ Error: Missing repository analysis")
  console.log("Run: /analyze to generate analysis first")
  return { error: "missing_input", required: "repository-analysis.json" }
}
```

### Handling Validation Failures
```javascript
if (validation.overall_status === "blocked") {
  console.log("❌ BLOCKED: Cannot commit")
  console.log("\nIssues:")
  validation.blocking_issues.forEach(issue => {
    console.log(`  - ${issue.severity}: ${issue.message}`)
  })
  console.log("\nFix issues and run /validate again")
  return { status: "blocked" }
}
```

### Handling Git Errors
```javascript
const result = execGitCommit(message, files)
if (result.exitCode !== 0) {
  console.log(`❌ Git commit failed: ${result.stderr}`)
  executionLog.errors.push({
    group_id: groupId,
    error: result.stderr,
    files: files
  })
  return { status: "failed", error: result.stderr }
}
```

---

## References

- Conventional Commits: `.claude/workflows/cli-templates/prompts/commitcraft/conventional-commits.txt`
- Quality Criteria: `.claude/workflows/cli-templates/prompts/commitcraft/quality-criteria.txt`
- Security Patterns: `.claude/workflows/cli-templates/prompts/commitcraft/security-patterns.txt`
- Documentation Generator: `~/.claude/scripts/commitcraft-doc-generator.sh`
